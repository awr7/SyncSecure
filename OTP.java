/* -- imports for auth -- */

import java.io.*;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.Random;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.catalina.*;
import org.apache.catalina.startup.Tomcat;
import org.apache.coyote.http11.filters.BufferedInputFilter;

/* -- imports for token -- */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import java.util.Random;

class OTP implements Runnable {  
  DuoT  T;                 
  DuoV  V;                 

  private ServerSocket serverSocket;

  private static final int N = 65537;
  private int seed = randomPos(N);
  private int a = randomPos(N);
  private int b = randomNat(N);
  private int count = 0;

  //Timer objects for the display in the GUI and to get a new OTP after 6 secs
  private Timer displayTimer;
  private Timer otpTimer;

  // used to display NOT READY when T not connected
  private boolean isConnected = false;

  //used to check if we seen OTP before
  private static final int MAX_OTPS = 65537;
  private String[] encounteredOTPs = new String[MAX_OTPS];
  private int otpsCount = 0;

// used to make a window so the last 5 OTPs are valid
  private static final int maxValidOTP = 5;
  private String[] validOTPs = new String [maxValidOTP];
  
public OTP(DuoT x)
{
    this.T = x;

    SendData(seed, a, b);

    startOtpTimer(seed, a, b);
}

public OTP(DuoV x)
{
    this.V = x;
    try{
        this.serverSocket = new ServerSocket(x.port + 1); // ServerSocket for DuoV on port+1
        new Thread(this).start(); // Start the thread to handle client connections
        System.out.println("V port: " + V.port);
        System.out.println("x port: "+ x.port);
    } catch (IOException e) {
    //    System.err.println("Couldn't get I/O for the connection to " + host);
        System.exit(1);
    }
}

// V gets initialized here, accepts connections and generate OTPs
@Override
public void run() {
    while (true) {
        try (Socket clientSocket = serverSocket.accept();
        // BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) {
            InputStream in = clientSocket.getInputStream()) {
            System.out.println("New connection detected! "  + clientSocket.getInetAddress());
            isConnected = true;
            byte[] byteArray = new byte[6]; // 3 shorts x 2 bytes each
            in.read(byteArray, 0, 6);

            // Unpack the byte array into three integers
            ByteBuffer buffer = ByteBuffer.wrap(byteArray);
            int receivedSeed = Short.toUnsignedInt(buffer.getShort());
            int receivedA = Short.toUnsignedInt(buffer.getShort());
            int receivedB = Short.toUnsignedInt(buffer.getShort());

            System.out.println("Received seed = " + receivedSeed + " a = " + receivedA + " b = " + receivedB);
            String otp = generateOTP(receivedSeed, receivedA, receivedB);
            System.out.println("OTP Generated by V: " + otp);

            startOtpTimer(receivedSeed, receivedA, receivedB);
            
        } catch (IOException e) {
        System.exit(1);
        }
    }
}

//T will send seed, a, b values to V
private void SendData(int seed, int a, int b) {
    try (Socket socket = new Socket(T.host, T.port);
    // PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
    OutputStream out = socket.getOutputStream()) {

        // Pack the three integers as unsigned shorts into a byte array
        ByteBuffer buffer = ByteBuffer.allocate(6); // 3 shorts x 2 bytes each
        buffer.putShort((short) seed);
        buffer.putShort((short) a);
        buffer.putShort((short) b);
        byte[] byteArray = buffer.array();

        out.write(byteArray);

        System.out.println("Sent seed = " + seed + " a = " + a + " b = " + b);
        String otp = generateOTP(seed, a, b);
        System.out.println("OTP Generated by T: " + otp);

    } catch (IOException e) {
        System.exit(1);
    }
}

//method for updating which OTPs are valid (the last 5)
private void updateValidOTPs(String newOtp) {
    System.out.println("new OTP in verify: " + newOtp);
    int len = validOTPs.length;
    for(int i = len-1; i>=0;i--){
        if(i == 0){
            validOTPs[i] = newOtp;
        }
        else {
            validOTPs[i] = validOTPs[i-1];
        }
    }

}

// Verfies the OTPs and changes the dispay area with SUCCESS, ERROR(USED), etc
public String verify(HttpServletRequest req) {

  String user_passcode = req.getParameter("myOTP");

  if (!isConnected) {
    return "NOT READY";
  }


  if (isOTPEncounteredBefore(user_passcode)) {
    return "FAILED (USED)";
  }
  
  if (isValidOTP(user_passcode)) {
    storeUsedOTP(user_passcode);
    return "SUCCESS";
  }
  
  if (!isValidOTP(user_passcode)) {
    return "FAILED (ERROR)";
  }

  else {
    return "ERROR";
  }
}

//checks if OTP is in our valid window
private boolean isValidOTP(String user_passcode) {
    for (String otp : validOTPs) {
        if (user_passcode.equals(otp)) {
            return true;
        }
    }
    return false;
}

// checks if OTP was used
private boolean isOTPEncounteredBefore(String otp) {
    for (int i = 0; i < otpsCount; i++) {
        if (encounteredOTPs[i].equals(otp)) {
            return true;
        }
    }
    return false;
}

// stores used OTPs
private void storeUsedOTP(String otp) {
    if (otpsCount < MAX_OTPS) {
        encounteredOTPs[otpsCount++] = otp;
    } else {
        System.out.println("Reached maximum OTP storage capacity.");
    }
}

// after 6 seconds this gets called and the GUI text resets to ----
private void clearOTPDisplay() {
    T.label1.setText( "----" );
}

//increase count every 6 seconds to get a new OTP
private void incrementCount(int seed, int a, int b) {
    this.count++;
    // System.out.println("Counter incremeneted " + count + "at time = "+ System.currentTimeMillis());
    generateOTP(seed, a, b);
}

// timer that calls incrementcount every 6 seconds
private void startOtpTimer (int seed, int a, int b) {
    otpTimer = new Timer(6000, e -> incrementCount(seed,a,b));
    otpTimer.setRepeats(true); // Make sure it repeats
    otpTimer.start(); // Start the timer
}

// handles button presses in the GUI
public void handleEvent(ActionEvent e) {
    String otp = generateOTP(this.seed, this.a, this.b);
    T.label1.setText( otp );

    if (displayTimer != null ) {
        displayTimer.stop();
    }
    //is a different timer than otpTimer because we want it to clear
    // 6 seconds after the button is pressed
    displayTimer = new Timer(6000, evt1 -> clearOTPDisplay());
    displayTimer.setRepeats(false);
    displayTimer.start();

}

// generates a number between 0 and N (inclusive)
private int randomNat(int N) {
    // return a random number in range of N
    Random random = new Random();
    int randomInt = random.nextInt(N + 1); // Produces a random number between 0 and N (inclusive)
    return (randomInt);
}

// generates a number between 1 and N
private int randomPos(int N){
    return (1+ randomNat(N-1));
}

private String generateOTP(int seed, int a, int b) {

    long otpValue = ((long) a * (seed + this.count) + b) % N;

    // if OTP is not 5 digits it adds leading zeros
    String formattedOTP = String.format("%05d", otpValue);

    updateValidOTPs( formattedOTP); 
    return formattedOTP;
} 

}
